<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synchronized GLSL Shader Desktop Background</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body, html {
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: monospace;
            font-size: 14px;
            text-align: center;
        }

        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            font-family: monospace;
            font-size: 14px;
            display: none;
            white-space: pre-wrap;
            max-width: 80%;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="loading">Loading shader...</div>
    <div id="error"></div>

    <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
in vec2 position;
void main() {
    gl_Position = vec4(position, 0.0, 1.0);
}
    </script>

    <script>
        // ============================================================
        // TIME-SYNCHRONIZED SHADER SELECTOR
        // ============================================================
        // All instances viewing this page at the same time will see
        // the same shader, changing at synchronized intervals.
        //
        // URL Parameters:
        //   ?interval=X  - Change shader every X minutes (default: 60)
        //   ?mode=sequential - Cycle through shaders in order (default: random)
        //
        // Examples:
        //   sync.html              - Random shader every hour
        //   sync.html?interval=30  - Random shader every 30 minutes
        //   sync.html?interval=120&mode=sequential - Sequential every 2 hours
        // ============================================================

        const AVAILABLE_SHADERS = [
            'default',
            'hexagon_x5',
            'trippy1',
            'speed',
            'fractal',
            'zoom',
            'tiles',
            'urchin',
            'stars',
            'ocean',
            'belatro',
            'mario',
            'clouds',
            'tunnel',
            'whirlpool',
            'circle',
            'crumple',
            'eyeball',
            'spike',
            'truchet',
            'fovea',
            // 'prettyhip',
            'gentle',
            'hypnosis',
            'subversion'
        ];

        // Parse URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const INTERVAL_MINUTES = parseInt(urlParams.get('interval')) || 60;
        const MODE = urlParams.get('mode') || 'random';
        const AA_QUALITY = 1.0;

        // Calculate current time slot
        function getCurrentTimeSlot() {
            const now = new Date();
            const totalMinutes = now.getHours() * 60 + now.getMinutes();
            return Math.floor(totalMinutes / INTERVAL_MINUTES);
        }

        // Select shader based on time slot
        function selectShaderForTimeSlot(timeSlot) {
            if (MODE === 'sequential') {
                // Cycle through shaders in order
                return AVAILABLE_SHADERS[timeSlot % AVAILABLE_SHADERS.length];
            } else {
                // Random but deterministic based on time slot
                // Use simple hash to get consistent "random" selection
                const hash = (timeSlot * 2654435761) % 2147483647;
                return AVAILABLE_SHADERS[hash % AVAILABLE_SHADERS.length];
            }
        }

        // Calculate milliseconds until next interval
        function msUntilNextInterval() {
            const now = new Date();
            const currentMinute = now.getHours() * 60 + now.getMinutes();
            const currentSecond = now.getSeconds();
            const currentMs = now.getMilliseconds();

            const minutesIntoInterval = currentMinute % INTERVAL_MINUTES;
            const minutesUntilNext = INTERVAL_MINUTES - minutesIntoInterval;
            const secondsUntilNext = minutesUntilNext * 60 - currentSecond;
            const msUntilNext = secondsUntilNext * 1000 - currentMs;

            return msUntilNext;
        }

        const currentTimeSlot = getCurrentTimeSlot();
        const CURRENT_SHADER = selectShaderForTimeSlot(currentTimeSlot);

        // Schedule auto-reload at next interval
        const reloadDelay = msUntilNextInterval();
        console.log(`Current shader: ${CURRENT_SHADER}`);
        console.log(`Time slot: ${currentTimeSlot}`);
        console.log(`Next shader change in ${Math.floor(reloadDelay / 1000 / 60)} minutes`);

        setTimeout(() => {
            console.log('Interval elapsed, reloading for new shader...');
            window.location.reload();
        }, reloadDelay);

        // Update loading message
        const loadingDiv = document.getElementById('loading');
        loadingDiv.innerHTML = `Loading shader...<br><small>Current: ${CURRENT_SHADER}<br>Changes in ${Math.floor(reloadDelay / 1000 / 60)} min</small>`;

        // ============================================================
        // WebGL 2.0 setup (same as shader.html)
        // ============================================================

        const canvas = document.getElementById('glCanvas');
        const errorDiv = document.getElementById('error');
        const gl = canvas.getContext('webgl2', { antialias: false, alpha: false });

        if (!gl) {
            showError('WebGL 2.0 not supported in your browser');
            throw new Error('WebGL 2.0 not supported');
        }

        function showError(message) {
            loadingDiv.style.display = 'none';
            errorDiv.style.display = 'block';
            errorDiv.textContent = message;
            console.error(message);
        }

        function hideLoading() {
            loadingDiv.style.display = 'none';
        }

        // Resize canvas to match window size with super-sampling for anti-aliasing
        function resizeCanvas() {
            canvas.width = window.innerWidth * AA_QUALITY;
            canvas.height = window.innerHeight * AA_QUALITY;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const error = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                return { error };
            }

            return { shader };
        }

        // Create program
        function createProgram(vertexSource, fragmentSource) {
            const vertexResult = compileShader(vertexSource, gl.VERTEX_SHADER);
            if (vertexResult.error) {
                return { error: 'Vertex shader error:\n' + vertexResult.error };
            }

            const fragmentResult = compileShader(fragmentSource, gl.FRAGMENT_SHADER);
            if (fragmentResult.error) {
                return { error: 'Fragment shader error:\n' + fragmentResult.error };
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexResult.shader);
            gl.attachShader(program, fragmentResult.shader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                return { error: 'Program link error:\n' + gl.getProgramInfoLog(program) };
            }

            return { program };
        }

        // Build fragment shader from template and loaded code
        function buildFragmentShader(shaderCode) {
            return `#version 300 es
precision highp float;

uniform vec2 iResolution;
uniform float iTime;
uniform float iTimeDelta;
uniform vec4 iMouse;

out vec4 fragColor;

// ============================================================
// Shader code loaded from: shaders/${CURRENT_SHADER}.glsl
// ============================================================

${shaderCode}

// ============================================================

void main() {
    mainImage(fragColor, gl_FragCoord.xy);
}
`;
        }

        // Load and initialize shader
        async function loadShader() {
            try {
                // Fetch shader code from file
                const response = await fetch(`shaders/${CURRENT_SHADER}.glsl`);
                if (!response.ok) {
                    throw new Error(`Failed to load shader: ${response.status} ${response.statusText}\nMake sure shaders/${CURRENT_SHADER}.glsl exists!`);
                }

                const shaderCode = await response.text();

                // Get vertex shader source
                const vertexSource = document.getElementById('vertex-shader').textContent;

                // Build fragment shader with loaded code
                const fragmentSource = buildFragmentShader(shaderCode);

                // Create shader program
                const result = createProgram(vertexSource, fragmentSource);
                if (result.error) {
                    showError(result.error);
                    return;
                }

                const program = result.program;
                gl.useProgram(program);

                // Create buffer for full-screen quad
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1,
                ]);

                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                const positionLocation = gl.getAttribLocation(program, 'position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                // Get uniform locations
                const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
                const iTimeLocation = gl.getUniformLocation(program, 'iTime');
                const iTimeDeltaLocation = gl.getUniformLocation(program, 'iTimeDelta');
                const iMouseLocation = gl.getUniformLocation(program, 'iMouse');

                // Smooth mouse tracking with liquid-like lag
                let targetMouseX = 0;
                let targetMouseY = 0;
                let mouseX = 0;
                let mouseY = 0;
                let mouseClickX = 0;
                let mouseClickY = 0;

                canvas.addEventListener('mousemove', (e) => {
                    targetMouseX = e.clientX;
                    targetMouseY = canvas.height - e.clientY; // Flip Y coordinate
                });

                canvas.addEventListener('mousedown', (e) => {
                    mouseClickX = e.clientX;
                    mouseClickY = canvas.height - e.clientY;
                });

                canvas.addEventListener('mouseup', () => {
                    mouseClickX = 0;
                    mouseClickY = 0;
                });

                // Animation loop
                let startTime = Date.now();
                let lastTime = 0;

                function render() {
                    const currentTime = (Date.now() - startTime) / 1000.0;
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;

                    // Smooth mouse interpolation for liquid-like lag
                    const smoothing = 0.08; // Lower = more lag, higher = more responsive
                    mouseX += (targetMouseX - mouseX) * smoothing;
                    mouseY += (targetMouseY - mouseY) * smoothing;

                    // Set uniforms
                    gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
                    gl.uniform1f(iTimeLocation, currentTime);
                    gl.uniform1f(iTimeDeltaLocation, deltaTime);
                    gl.uniform4f(iMouseLocation, mouseX, mouseY, mouseClickX, mouseClickY);

                    // Clear and draw
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    requestAnimationFrame(render);
                }

                hideLoading();
                render();

                console.log(`Synchronized shader loaded: ${CURRENT_SHADER}.glsl`);

            } catch (error) {
                showError('Error loading shader:\n' + error.message);
            }
        }

        // Start loading
        loadShader();
    </script>
</body>
</html>
